package concurrency.libs.flow

//State Flow, SharedFlow

/**
 * SharedFlow это горячий источник данных который эмитит события всем своим подписчикам
 * - Никогда не останавливается. Бесконечный поток данных. При попытке вызвать collect или toList() корутина будет приостановлена навсегда
 * - Горячий потому что его экземпляр существует независимо от его подписчиков в отличие от Flow который стартует только при вызове collect и сотавноавливается при отписке
 * - Может содержать несколько подписчиков
 * - Не имеет контекста выполнения. Вызов flowOn не оказывает какого либо влияния на него
 * - Поделен на мутабельный и иммутабельный как колекции в Kotlin. Mutable позволяет добавлять значения
 * - По умолчанию не сохраняет никаких значений, а просто служит передатчиком данных из эмиттера в подписчики
 * - В такой конфигурации вызов emit будет прерывать корутину до тех пор,пока подписчики не смогут принять значение
 *
 * Настройка буферизации
 * replayCache - Элементы доставляются всем новым подписчикам
 * extraBuffer - Элементы сохраняются при наличии подписчиков, когда они не могут быть доставлены сразу же. Очищается при отсутствии подписчиков
 * Свойства буферизации можно сбросит ьс помощью функции resetReplayCache() или получить их списком через свойство replayCache
 *
 *
 * StateFlow это частный случай SharedFlow
 * Специальный горячий флоу который хранит одно значение и доставляет его всем своим подписчикам
 * Новое значение будет доставлено только если оно изменилось, т.e equals вернул false. Иначе попытка его эмита будет игнорироваться.
 * StateFlow эквивалентен SharedFlow(replay = 1, extraBufferCapacity = 0, onBufferOverflow = BufferOverflow.DROP_OLDEST)
 * */